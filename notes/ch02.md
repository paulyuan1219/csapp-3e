### 2.1.6 布尔代数

布尔代数
- 长度为w的位向量上的布尔运算| & ~ 构成布尔代数
- 类似于整数的算数运算
- &对于|有分配率 a & (b | c) = (a & b) | (a & c)
- |对于&有分配率 a | (b & c) = (a | b) & (a | c)

布尔环
- 长度为w的位向量上的布尔运算^ & ~ 构成布尔ring
- 类似于整数的算数运算
- 类似于 x + (-x) = 0，这里有a^a=0，这里的加法运算是^,逆元是a本身
- 而且，连续的^可以交换并且可结合的，比如(a ^ b) ^ a = b

### 2.1.7 位运算
Masking Operations
- a mask is a bit pattern that indicates a selected set of bits within a word


# Exercise
## 2.12
The tricky part is as follows, for every bit:
- ? ^ 1 就是取补
- ？^ 0 保持不变
- ? & 0 = 0
- ? & 1 = ?
- ? | 0 = ?
- ? | 1 = 1

所以答案如下
A. x & oxFF 根据上面的trick，很容易看出高位都是0 ，低位就是x的低位
B. x ^ ~0xFF 根据trick就可以
C. x | 0xFF

## 2.13

These problems help you think about the relation between Boolean operations and typical ways that programmers apply masking operations. Here is the code:

```
/* Declarations of functions implementing operations bis and bic */
int bis(int x, int m);
int bic(int x, int m);
/* Compute x|y using only calls to functions bis and bic */
int bool_or(int x, int y) {
  int result = bis(x,y);
  return result;
}
/* Compute x^y using only calls to functions bis and bic */
int bool_xor(int x, int y) {
  int result = bis(bic(x,y), bic(y,x));
  return result;
}
```

The bis operation is equivalent to Boolean or—a bit is set in z if either this bit is set in x or it is set in m. On the other hand, bic(x, m) is equivalent to x & ~m; we want the result to equal 1 only when the corresponding bit of x is 1 and of m is 0.
Given that, we can implement | with a single call to bis. To implement ^, we take advantage of the property
x ^y =(x &~y)|(~x &y)

核心思想如下：
- bis(x,m) 等价于 x OR m
  - 如果m的对应位置是1，那么结果就是1
  - 如果m的对应位置是0，那么结果就是x中原来的值
  - 综上所述，其实就是OR操作
- bic(x,m) 等价于 x & ~m
  - 首先翻转m
  - 然后根据~m来设置，如果对应位置是0，那么就是x原来的值；如果对应位置是1，就设置为0
  - 整体效果就是 x & ~m
- 我们知道下面的等式
  - x ^y =(x &~y)|(~x &y)
  - 所以只需要按原样实现即可。有趣有趣。

## 2.15
第一次自己想出来
如果x y完全相等，那么几个位运算中，只有^最可能，因为x^x = 0, x^y = 1 when x <> y
然后通过！来取反即可。
